= javascript_include_tag 'jquery-ui'
%div{ :class=>"hide", :id=>"info"}
%div{ :class=>"hide", :id=>"TextFormDiv"}
   %form{:id=>"TextForm", :autocomplete=>"off"}
      %TEXTAREA {:id=>"textBoxMultiline", :COLS=>40, :ROWS=>2}
      %input.activeTextObjectId
      %br
      %input {:type=>"submit", :value=>"Submit"}
      %input {:type=>"button", :name=>"cancel" :value=>"Cancel" :onClick=>"textcancel()"}
%div{:class=>"hide", :id=>"LabelFormDiv"}
   %form{ :id=>"LabelForm", :autocomplete=>"off"}
      %input{ :id=>"textBox", :placeholder=>"your text", :autocomplete=>"off"}
      %input{ :id=>"activeObjectId"}
      %br
      %input{ :type=>"submit", :value=>"Submit"}
      %input{ :type=>"button", :name=>"cancel", :value=>"Cancel", :onClick=>"labelcancel()"}
%div#inputs
%div#menubar
   =image_tag "paint_bucket.png"
   %input{:id=>'myColor', :class=>'color {pickerClosable:true}', :onchange=>"colorPickerChange('#'+this.color)", :style=>'width:2em;', :value=>'000000'}
   =image_tag "FastText.png"
   %input{:id=>'myFontColor', :class=>'color {pickerClosable:true}', :onchange=>"myFontColor('#'+this.color)", :style=>'width:2em;', :value=>'000000'}
   Customer:
   = @drawing.customer
   Opportunity:
   = @drawing.opportunity
%div{:id=>"accordian-canvas-wrapper", :style=>"position:relative;top:60px;height:1000px;width:100%;"}
   %div{:id=>"accordian-container"}
      %div{ :id=>"accordion" }
         %h3 Cameras
         %div{:style=>"margin:0px;padding:0px;"}
            %div{:id=>"images"}
               %table
                  %tr
                     %td
                        = image_tag "IED.png", :img_val=>"IED.png", :draggable=>"true", :width=>"71", :height => "34"
                        %figcaption IED
                     %td
                        = image_tag "esprit_cam.png", :img_val=>"esprit_cam.png", :draggable=>"true", :width=>"71", :height => "34"
                        %figcaption Esprit Cam
                  %tr
                     %td
                        = image_tag "Switch.png", :img_val=>"Switch.png", :draggable=>"true", :width=>"108", :height => "75"
                        %figcaption Switch
                     %td
                        = image_tag "GE_WiYZ.png", :img_val=>"GE_WiYZ.png", :draggable=>"true", :width=>"72", :height => "83"
                        %figcaption WiYZ
                  %tr
                     %td
                        = image_tag "line.png", :img_val=>"line.png", :draggable=>"true", :width=>"22", :height => "39"
                        %figcaption Line
                     %td
                        = image_tag "textbox_icon.png", :img_val=>"textbox_icon.png", :draggable=>"true", :width=>"60", :height => "32"
                        %figcaption Text Box
         %h3 Networking
         %div{:style=>"margin:0px;padding:0px;"}
         %h3 Shapes
         %div{:style=>"margin:0px;padding:0px;"}
   %div{:id=>"div2", :style=>"position:absolute;left:230px"}
      %div{:id=>"canvas-container"}
         %canvas{:id=>"demoCanvas2", :width=>"1000", :height=>"800"}

:javascript
     var handler = "";
     var c = new Array();
     var objId_var = 0;
     var contextmenuon = false;
     var activeObject = false;
     var activeObjectVal = "";
     var activeLineGroup = null;
     var objectName = "";
     var _curX, _curY;
     var adjustedX = false;
     var adjustedY = false;
     var freezeY = 0;
     var freezeX = 0;
     var lastScrollY = 0;
     var lastScrollX = 0;
     var canvas = new fabric.CanvasEx('demoCanvas2');
     var motionInbounds = true;
     //$('.canvas-container').on('scroll', canvas.calcOffset.bind(canvas));
     window.onscroll = function(ev) {
            canvas.calcOffset.bind(canvas)
            var scrollY = $(window).scrollTop();
            console.log("Window is scrolling" + scrollY)
            _curY = _curY - (scrollY - lastScrollY);
            lastScrollY = scrollY;
            var scrollX = $(window).scrollLeft();
            console.log("Window is scrolling" + scrollX)
            _curX = _curX - (scrollX - lastScrollX);
            lastScrollX = scrollX;
     }
     if(!window.location.hash) {
         window.location = window.location + '#loaded';
         window.location.reload();
     }else{
         $( "#accordion" ).accordion();
         console.log( "ready!" );
         var data_drawing = "";
         if (parseInt("#{@drawing.drawing.length}") > 0) {
              data_drawing = #{ raw(@drawing.drawing) }
         } else {
              data_drawing = ""
         }
         objId_var = 1;
         if (data_drawing != "") {
            canvas.clear();
            canvas.loadFromJSON(data_drawing, canvas.renderAll.bind(canvas), function(o, object) {

             if (object.type == "image") {
               object.on("mousedown", function(data, index) { imageDown(data,index)   });
             }
             if (object.type == "line") {
               object.hasBorders = object.hasControls = false;
               object.objId = objId_var;
               c[objId_var] = makeCircle(object);
               c[objId_var][0].top =  object.getTop() + object.height/2 + object.y1;
               c[objId_var][0].left = object.left + object.width/2 + object.x1;
               c[objId_var][0].setCoords();
               c[objId_var][1].top =  object.getTop() + object.height/2 +  object.y2;
               c[objId_var][1].left = object.left + object.width/2 + object.x2;
               c[objId_var][1].setCoords();
               object.c1 = c[objId_var][0]
               object.c2 = c[objId_var][1]
               canvas.add(c[objId_var][0],c[objId_var][1]);
               object.on("mousedown", function(data, index) { lineDown(data,index); });
               object.c1.setCoords();
               object.c2.setCoords();
               object.setCoords();
               objId_var = objId_var + 1;
               object.on("mousedown", function(data, index) { lineDown(data,index); });
             }
             if (object.type == "text") {
               object.on("mousedown", function(data, index) { textDown(data,index)   });
             }

           });

         }
         canvas.renderAll();
         console.log( "Drawing should be loaded ");
     }

     canvas.on('mouse:over', function(e) {
        e.target.setOpacity(0.5);
        activeObject = true;
        activeObjectVal = e.target;
        canvas.renderAll();
     });

     canvas.on('object:selected', function(e) {
        //find the selected object type
        adjustedY  = false
        adjustedYb = false
        adjustedX  = false
        adjustedXb = false
        console.log("object:selected starting")
        console.log("_curX: " + _curX);
        console.log("_curY: " +_curY);
        //console.log(e.target)
        var objType = e.target.get('type');
        if (objType == 'line') {
          console.log("object:selected removing circles")
          _curX = e.e.clientX;
          _curY = e.e.clientY;
          e.target.c1.remove();
          e.target.c2.remove();
          canvas.renderAll();
        }

     });

     canvas.on('mouse:up', function(e) {
         //console.log("In mouse:up")
         //console.log(e.target)
         if(e.target) {
           //console.log("Target")
           //console.log(e.target)
           if('type' in e.target) {
             if(e.target.type == "line") {
               c[e.target.objId] = makeCircle(e.target)
               canvas.add(c[e.target.objId][0],c[e.target.objId][1]);
               c[e.target.objId][0].top =  e.target.y1;
               c[e.target.objId][0].left = e.target.x1;
               c[e.target.objId][0].setCoords();
               c[e.target.objId][1].top =  e.target.y2;
               c[e.target.objId][1].left = e.target.x2
               c[e.target.objId][1].setCoords();
               e.target.c1 = c[e.target.objId][0];
               e.target.c2 = c[e.target.objId][1];
               e.target.set({ 'x1': e.target.c1.left, 'y1': e.target.c1.top });
               e.target.set({ 'x2': e.target.c2.left, 'y2': e.target.c2.top });
               c[e.target.objId][0].line && c[e.target.objId][0].line.set({ 'x1': c[e.target.objId][0].left, 'y1': c[e.target.objId][0].top });
               c[e.target.objId][0].line.setCoords();
               c[e.target.objId][1].line && c[e.target.objId][1].line.set({ 'x2': c[e.target.objId][1].left, 'y2': c[e.target.objId][1].top });
               c[e.target.objId][1].line.setCoords();
               e.target.setCoords();
               e.target.c1.setCoords();
               e.target.c2.setCoords();
               //console.log(e.target)
             }
           }
        }
     })

     canvas.on('mouse:down', function(e) {
         //console.log("In Canvas On Mouse:down")
         handler =""
         $('#glossymenu').remove();
         contextmenuon = false;
         if(e.target) {
           //console.log("Target")
           //console.log(e.target)
           if('type' in e.target) {
             if(e.target.type == "line") {
               if (e.target.c1) {
                 e.target.c1.remove();
                 e.target.c2.remove();
                 canvas.renderAll();
               }
             }
           }
         }
     });

     canvas.on('mouse:out', function(e) {
        //console.log("Mouse:out")
        //console.log(e.target)
        e.target.setOpacity(1);
        canvas.renderAll();
        activeObject = false;
        objectName ="";

     });


     canvas.on('object:moving', function(e) {
        var p = e.target;
        //console.log("Event")
        //console.log(e);
        console.log("object:moving starting")
        console.log("_curX: " + _curX);
        console.log("_curY: " +_curY);
        if(p.type == 'circle1') {
           p.line && p.line.set({ 'x2': p.left, 'y2': p.top });
           p.line.setCoords();
        }
        if(p.type == 'circle0') {
           p.line && p.line.set({ 'x1': p.left, 'y1': p.top });
           p.line.setCoords();
        }
        canvas.renderAll();

        if(e.target.type == 'line') {
          var _curXm = (_curX - e.e.clientX);
          var _curYm = (_curY - e.e.clientY);
          if(adjustedY) {
              _curYm = _curY - freezeY
              adjustedY = false;
          }
          if(adjustedYb) {
              _curYm = _curY - freezeYb
              adjustedYb = false;
          }
          if(adjustedX) {
              _curXm = _curX - freezeX
              adjustedX = false;
          }
          if (adjustedXb) {
             _curXm = _curX - freezeXb
             adjustedXb = false;
          }
          //console.log("moved: " + _curXm);
          //console.log("moved: " + _curYm);
          e.target.c1.set({ 'left' : e.target.c1.left - _curXm, 'top' : e.target.c1.top - _curYm });
          e.target.c2.set({ 'left' : e.target.c2.left - _curXm, 'top' : e.target.c2.top - _curYm  });
          e.target.set({ 'x1': e.target.c1.left, 'y1': e.target.c1.top });
          e.target.set({ 'x2': e.target.c2.left, 'y2': e.target.c2.top });
          e.target.c2.setCoords();
          e.target.c1.setCoords();
          e.target.setCoords();
          canvas.renderAll();
        }
          _curX = e.e.clientX;
          _curY = e.e.clientY;
          console.log("clientY: " + e.e.clientY)
     });

     // canvas moving limit

     canvas.observe("object:moving", function(e){
       //alert("oval moving");
       var obj = e.target;
       // if object is too big ignore
       //console.log("In canvas.observe object.moving")
       //console.log(obj)
       var halfw = obj.width/2;
       var halfh = obj.height/2;
       var posBottom = obj.top + obj.height;
       var posRight = obj.left + obj.width;
       var bounds = {tl: {x: halfw, y:halfh},
         br: {x: canvas.width , y: canvas.height }
       };

       // top-left  corner

         // alert("text");
       if(obj.top < bounds.tl.y || obj.left < bounds.tl.x){
         e.target.setTop(Math.max(obj.top, '0'  ));
         e.target.left = Math.max(obj.left , '0' );
         e.target.setCoords();
         canvas.renderAll();
         //console.log("At Top/Left boundary")
         //console.log("Line Top Calculated: " + Math.max(e.target.top, '0'  ))
         //console.log("Line Top Retrieved : " + e.target.top)
         console.log("x1 : " + e.target.x1)
         console.log("x2 : " + e.target.x2)
         minY = Math.min(e.target.y1, e.target.y2)
         minX = Math.min(e.target.x1, e.target.x2)
         console.log("minX : " + minX)
         if(!adjustedY ) {
            freezeY = e.e.clientY
         }

         if(!adjustedX ) {
            freezeX = e.e.clientX
            console.log("Not Adjusted FreezeX: " + freezeX)
         } else {
            console.log("FreezeX is frozen")
         }

         if (minY < 0)
         {
            e.target.y1 = e.target.y1 - minY
            e.target.y2 = e.target.y2 - minY
            e.target.setCoords();
            adjustedY = true;

         }
         if (minX < 0)
         {
            console.log("minX less than 0")
            e.target.x1 = e.target.x1 - minX
            e.target.x2 = e.target.x2 - minX
            e.target.setCoords();
            adjustedX = true;

         }
         //console.log(e.target);
       }



     // bot-right corner
     if(posBottom > bounds.br.y || posRight > bounds.br.x ){
         //console.log("In second canvas.observe if")
         obj.top = Math.min(posBottom, bounds.br.y  ) - obj.height;
         obj.left = Math.min(posRight, bounds.br.x ) - obj.width;
         obj.setCoords();
         maxY = Math.max(e.target.y1, e.target.y2)
         maxX = Math.max(e.target.x1, e.target.x2)
         console.log("maxX : " + maxX)
         console.log("maxY : " + maxY)
         if(!adjustedYb ) {
            freezeYb = e.e.clientY
         }

         if(!adjustedXb ) {
            freezeXb = e.e.clientX
            console.log("Not Adjusted FreezeXb: " + freezeX)
         } else {
            console.log("FreezeX is frozen")
         }

         if (maxY > bounds.br.y)
         {
            e.target.y1 = e.target.y1 - (maxY - bounds.br.y)
            e.target.y2 = e.target.y2 - (maxY - bounds.br.y)
            e.target.setCoords();
            adjustedYb = true;

         }
         if (maxX > bounds.br.x)
         {
            console.log("minX less than 0")
            e.target.x1 = e.target.x1 - (maxX - bounds.br.x)
            e.target.x2 = e.target.x2 - (maxX - bounds.br.x)
            e.target.setCoords();
            adjustedXb = true;

         }
     }

     // top-right corner case
     if (obj.top < bounds.tl.y && posRight > bounds.br.x) {
       obj.top = Math.max(obj.top, '0'  );
       obj.left = Math.min(posRight, bounds.br.x ) - obj.width;
       obj.setCoords();
     }

     // bottom-left corner case
     if (posBottom > bounds.br.y && obj.left < bounds.tl.x) {
       obj.top = Math.min(posBottom, bounds.br.y  ) - obj.height;
       obj.left = Math.max(obj.left , '0' )
       obj.setCoords();
     }
     });

     if (Modernizr.draganddrop) {
       // Browser supports HTML5 DnD.

       // Bind the event listeners for the image elements
       var images = document.querySelectorAll('#images img');
       [].forEach.call(images, function (img) {
          img.addEventListener('dragstart', handleDragStart, false);
          img.addEventListener('dragend', handleDragEnd, false);
       });
       // Bind the event listeners for the canvas
       var canvasContainer = document.getElementById('canvas-container');
       canvasContainer.addEventListener('dragenter', handleDragEnter, false);
       canvasContainer.addEventListener('dragover', handleDragOver, false);
       canvasContainer.addEventListener('dragleave', handleDragLeave, false);
       canvasContainer.addEventListener('drop', handleDrop, false);
     } else {
       // Replace with a fallback to a library solution.
       alert("This browser doesn't support the HTML5 Drag and Drop API.");
     }
